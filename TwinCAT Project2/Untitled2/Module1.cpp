///////////////////////////////////////////////////////////////////////////////
// Module1.cpp
//Author:       Adam Ryason
//Version:      1.0
//Date:           6/18/2018
#include "TcPch.h"
#pragma hdrstop

#include "Module1.h"

# define pi           3.14159265358979323846

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CModule1
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CModule1
BEGIN_INTERFACE_MAP(CModule1)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_ITCOMOBJECT(CModule1)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CModule1)
IMPLEMENT_ITCADI(CModule1)
IMPLEMENT_ITCWATCHSOURCE(CModule1)


///////////////////////////////////////////////////////////////////////////////
// Set parameters of CModule1 
BEGIN_SETOBJPARA_MAP(CModule1)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_Module1Parameter, m_Parameter)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CModule1 
BEGIN_GETOBJPARA_MAP(CModule1)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_Module1Parameter, m_Parameter)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CModule1
BEGIN_OBJPARAWATCH_MAP(CModule1)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CModule1
BEGIN_OBJDATAAREA_MAP(CModule1)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_Module1Inputs, m_Inputs)
	OBJDATAAREA_VALUE(ADI_Module1Outputs, m_Outputs)
	OBJDATAAREA_VALUE(ADI_Module1ADS_data, m_ADS_data)
	OBJDATAAREA_VALUE(ADI_Module1Controls, m_Controls)
	OBJDATAAREA_VALUE(ADI_Module1System, m_System)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CModule1::CModule1()
	: m_Trace(m_TraceLevelMax, m_spSrv)
	, m_counter(0)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	memset(&m_Parameter, 0, sizeof(m_Parameter));
	memset(&m_Inputs, 0, sizeof(m_Inputs));
	memset(&m_Outputs, 0, sizeof(m_Outputs));
	memset(&m_ADS_data, 0, sizeof(m_ADS_data));
	memset(&m_Controls, 0, sizeof(m_Controls));
	memset(&m_System, 0, sizeof(m_System));
///</AutoGeneratedContent>

}

///////////////////////////////////////////////////////////////////////////////
CModule1::~CModule1() 
{
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CModule1)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CModule1::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	// TODO: Add initialization code
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CModule1::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// TODO: Add any additional initialization

	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller(); 
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CModule1::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	RemoveModuleFromCaller(); 

	// TODO: Add any additional deinitialization

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CModule1::SetObjStateSP()
{
	HRESULT hr = S_OK;
	m_Trace.Log(tlVerbose, FENTERA);

	// TODO: Add deinitialization code

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CModule1::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;

	//Ryason begin

	//Read the encoders for the angle
	read_angle();
	
	//If CALIBRATE variable is false, offset the angular position
    if (!m_System.CALIBRATE)
	{
		calibrate();
	}

    //If ZERO variable is true, set the end effector position to P0

    if (!m_ADS_data.ExternalComm.ZeroPos)
    {
        P0x = m_ADS_data.MotorComm.PX;
        P0y = m_ADS_data.MotorComm.PY;
        P0z = m_ADS_data.MotorComm.PZ;

        m_ADS_data.ExternalComm.ZeroPos = true;
    }

	
	//Calculates the real angular position and velocity
	convert_angle();

	//Calculates the real Cartesian position based on the real calibrated angles
	update_position();
	//update_jacobian();

	//Turn on the force feedback
	//if (m_Controls.FORCE_ON)
    if(m_System.FORCE_ON)
	{
		//Internal Option 1: Simple Joint Response
		//simple_joint_response();

		//Internal Option 2: Simple Cartesian Box Response (must uncomment set_reference_force)
		//simple_box_interior();

		//Internal Option 3: Simple Spherical Response

        //Internal Option 4: Laryngoscope Lift
        //if (m_ADS_data.ExternalComm.LaryngLiftSim)
        //{
        //    sim_laryngoscopelift();
        //}

		//Set Reference force 
		compensate_staticmu();
		force_response();
		compensate_gravity();
		set_reference_torque();

		//set_dynamic_torque();

	}
	else
	{
		//Set All torques = 0 //TURN ON BEFORE GOING SIM
		zero_torque();
	}
	
	//collision_response();
	//m_Outputs.TargetTorque1 = 0;
	//m_Outputs.RealPosition1 = (float)m_Inputs.ActualPosition1;

	//External Reference Force
	//Mechanism.SetReferenceForce(*ADS FORCE*);	

	//Ryason end

	return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT CModule1::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CModule1::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;

	m_Trace.Log(tlVerbose, FLEAVEA);
}

///////////////////////////////////////////////////////////////////////////////
// Ryason:		Reads the angle as int and converts to degree between 0 and 360 deg for actuator 2 & 3, -45 and 310 deg for actuator 1
//					and -90 and 270 deg for actuator 4
VOID CModule1::read_angle()
{
	//Range for DEG1 = -45 : 180
	//Range for DEG3 = -90 : 90

	DEG1 = (float)(m_Inputs.Q1_position % (2000 * 421875 / 6859)) / (2000 * 421875 / 6859) * (2*pi);
	if (DEG1 < -pi)
		DEG1 += 2 * pi;
	else if (DEG1  > pi)
		DEG1 += -2 * pi;

	DEG2 = (float)(m_Inputs.Q2_position % (2000 * 421875 / 6859)) / (2000 * 421875 / 6859) * 2 * pi;
	if (DEG2 < 0)
		DEG2 += 2 * pi;

	DEG3 = (float)(m_Inputs.Q3_position % (2000 * 4554 / 130)) / (2000 * 4554 / 130) * 2 * pi;
	if (DEG3 < 0)
		DEG3 += 2 * pi;

	DEG4 = (float)(m_Inputs.Q4_position % (2000 * 50)) / (2000 * 50) * 2 * pi;
	if (DEG4 < -pi/2)
		DEG4 += 2 * pi;
	else if (DEG4 > 3 * pi / 2)
		DEG4 += -2 * pi;

    //DEG5 = (float)(m_Inputs.Q3_position2 % 128) / 128 * 2 * pi;    //Based on Sensor 2 in Controller 3      
    //DEG5 = m_Inputs.Q3_position2;
    DEG5 = (float)((-(int)m_ADS_data.ArduinoComm.EncoderValue))/15000 * 2 * pi;
}

///////////////////////////////////////////////////////////////////////////////
// Ryason:  Calculates the offset for the desired home position based on the current angle (0:360 deg)
VOID CModule1::calibrate()
{
	m_Controls.Q1_offset = 0 * pi / 180 + DEG1;			//Main Left Actuator
	m_Controls.Q2_offset = 180*pi/180 - DEG2;		   //Main Right Actuator
	m_Controls.Q3_offset = 270 * pi / 180 + DEG3;	   //Wrist Actuator
	m_Controls.Q4_offset = 0 * pi / 180 + DEG4;         //Side Actuator
    m_Controls.Q5_offset = 0 * pi / 180 + DEG5;         //Wrist 2nd DOF

    phiOrig = 2.6;
    phiScale = 1.075;

	L1 = .2415;				//Length of link 1 (meter)
	L2 = .230332;			//Length of link 2 (meter)
	L3 = .171;					//Length of link 3 (meter)
	L4 = .095;					//Length of link 4 (meter)
	L5 = .05;					//Length of Q1 base to Wrist base
    LW = .09;                 //Length of wrist handle to 2nd dof

	g = 9.80655;			// units: m/s^2
	mA = 0.09692;			// units: kg
	mB = 0.01799;
	mC = 0.03941;
	mD = 0.05247;
	mE = 0.1636;
	mF = 0.09283;
    mG = 0.35222;
    mH = 0.23137;
    mI = 0.08985;
    mJ = 0.130634;
	mK = 0.03240;
	mL = mF;
	mM = 0.02973;
	mP = 0.09422;
	mQ = 0.4022;

	Acmx =.0394961;			// units: m
	Bcmx = .0473382;
	Ccmx = .0685778;
	Dcmx = .0555704;
	Dcmy = .0211434;
	Ecmx = .0628692;
	Ecmy = .0005104;
	Fcmx = -.0007880;
	Fcmz = .1207547;
    Gcmx = -.2059694;
    Gcmz = -.0039486;
    Hcmx = .01522695;
    Hcmz = .06699145;
	Icmx = -.0024208;
	Icmy = .0001238;
    Icmz = -.1129055;
    Jcmz = .11490801;
	Lcmx = Fcmx;
	Lcmz = Fcmz;
	Mcmx = .0327693;
	Mcmy = .0248118;
	Mcmz = -.0133316;
	Pcmx = -.2292301;
	Pcmy = -.0200391;
	Pcmz = .0126912;
	Qcmx = -.0152873;
	Qcmy = .0027558;
	Qcmz = .0185286;

    m_System.CALIBRATE = true;
}

///////////////////////////////////////////////////////////////////////////////
// Ryason:  Offsets the read angle (degrees) and places it on the range of 0:360 deg
VOID CModule1::convert_angle()
{	
	//ACTUATOR 1
	if (2 * pi > (-DEG1 + m_Controls.Q1_offset))
	{
		if (-pi < (-DEG1 + m_Controls.Q1_offset))
			m_Controls.Q1_realposition = -DEG1 + m_Controls.Q1_offset;
		else if (pi < (-DEG1 + m_Controls.Q1_offset))
			m_Controls.Q1_realposition = -DEG1 + m_Controls.Q1_offset - 2 * pi;
		else
			m_Controls.Q1_realposition = -DEG1 + m_Controls.Q1_offset + 2 * pi;
	}
	else
		m_Controls.Q1_realposition = -DEG1 + m_Controls.Q1_offset - 2 * pi;
	
	m_Controls.Q1_realvelocity = (float)(m_Inputs.Q1_velocity) / 3600*2*pi;

	//ACTUATOR 2
	if (2 * pi > (DEG2 + m_Controls.Q2_offset))
	{
		if (0 < (DEG2 + m_Controls.Q2_offset))
			m_Controls.Q2_realposition = DEG2 + m_Controls.Q2_offset;
		else
			m_Controls.Q2_realposition = DEG2 + m_Controls.Q2_offset + 2 * pi;
	}
	else
		m_Controls.Q2_realposition = DEG2 + m_Controls.Q2_offset - 2 * pi;

	m_Controls.Q2_realvelocity = (float)(m_Inputs.Q2_velocity) / 3600 * 2 * pi;

	//ACTUATOR 3
	if (2 * pi > (-DEG3 + m_Controls.Q3_offset))
	{
		if (0 < (-DEG3 + m_Controls.Q3_offset))
			m_Controls.Q3_realposition = -DEG3 + m_Controls.Q3_offset;
		else
			m_Controls.Q3_realposition = -DEG3 + m_Controls.Q3_offset + 2 * pi;
	}
	else
		m_Controls.Q3_realposition = -DEG3 + m_Controls.Q3_offset - 2 * pi;

	m_Controls.Q3_realvelocity = (float)(-m_Inputs.Q3_velocity) / 3600 * 2 * pi;

	//ACTUATOR 4
	if (2 * pi > (-DEG4 + m_Controls.Q4_offset))
	{
		if (-pi/2 < (-DEG4 + m_Controls.Q4_offset))
			m_Controls.Q4_realposition = -DEG4 + m_Controls.Q4_offset;
		else if (3 * pi / 2 < (-DEG4 + m_Controls.Q4_offset))
			m_Controls.Q4_realposition = -DEG4 + m_Controls.Q4_offset - 2 * pi;
		else
			m_Controls.Q4_realposition = -DEG4 + m_Controls.Q4_offset + 2 * pi;
	}
		else
			m_Controls.Q4_realposition = -DEG4 + m_Controls.Q4_offset - 2 * pi;

	m_Controls.Q4_realvelocity = (float)(-m_Inputs.Q4_velocity) / 3600 * 2 * pi;

    //ENCODER 5
    //if (2 * pi > (DEG5 + m_Controls.Q5_offset))
    //{
    m_Controls.Q5_realposition = DEG5 - m_Controls.Q5_offset;
    //}
}

///////////////////////////////////////////////////////////////////////////////
// Ryason:  Calculates the offset for the desired home position based on the current angle (0:2PI rad)
VOID CModule1::update_position()
{
	//IDK if this is the phi used previously
	//float phi = (m_Controls.Q4_realposition) * cos_(m_Controls.Q1_realposition + pi / 4)-pi/2;

	// Original Position Derivation
	//m_ADS_data.MotorComm.PX = L1*cos_(m_Controls.Q1_realposition)*cos_(phi) - L2*cos_(m_Controls.Q2_realposition);	//X, forward-back
	//m_ADS_data.MotorComm.PY = -L1*sin_(phi);																														//Y, left-right
	//m_ADS_data.MotorComm.PZ = L1*sin_(m_Controls.Q1_realposition)*cos_(phi) - L2*sin_(m_Controls.Q2_realposition);		//Z, up-down
	//m_ADS_data.MotorComm.PHI = m_Controls.Q3_realposition;

	phi	= -1*((m_Controls.Q4_realposition)* cos_(m_Controls.Q1_realposition + pi / 4)+pi/2);
	qB	= m_Controls.Q3_realposition + asin_(L5*sin_(m_Controls.Q3_realposition) / L4);
	qM = -1.047197551196598 + qB;
	qQ = -1.047197551196598 + qM;

    phiTemp = m_Controls.Q3_realposition - asin_(L5*sin_(2 * pi - m_Controls.Q3_realposition) / L4) - 0.8397;
    phiDelta = phiTemp - phiOrig;

    //2nd Wrist DOF not implemented via MGK *****
    //m_ADS_data.MotorComm.PHI = m_Controls.Q3_realposition - asin_(L5*sin_(2 * pi - m_Controls.Q3_realposition) / L4) - 0.8397;
    m_ADS_data.MotorComm.PHI = phiTemp + phiScale*phiDelta;
    m_ADS_data.MotorComm.PSI = m_Controls.Q5_realposition;
    m_ADS_data.MotorComm.PX = L1*sin_(m_Controls.Q1_realposition)*sin_(phi) - L2*cos_(m_Controls.Q2_realposition) + cos_(m_ADS_data.MotorComm.PHI)*LW*(cos_(m_ADS_data.MotorComm.PSI) - 1);		//X, forward-back
    m_ADS_data.MotorComm.PY = -L1*cos_(m_Controls.Q1_realposition)*sin_(phi) - L2*sin_(m_Controls.Q2_realposition) + sin_(m_ADS_data.MotorComm.PHI)*LW*(cos_(m_ADS_data.MotorComm.PSI) - 1);		//Y, left-right
    m_ADS_data.MotorComm.PZ = L1*cos_(phi) - sin_(m_ADS_data.MotorComm.PSI)*LW;

    /*m_ADS_data.MotorComm.PX = L1*sin_(m_Controls.Q1_realposition)*sin_(phi) - L2*cos_(m_Controls.Q2_realposition);		//X, forward-back
    m_ADS_data.MotorComm.PY = -L1*cos_(m_Controls.Q1_realposition)*sin_(phi) - L2*sin_(m_Controls.Q2_realposition);		//Y, left-right
    m_ADS_data.MotorComm.PZ = L1*cos_(phi);
    */
    
}

VOID CModule1::update_jacobian() //NOT UPDATED FOR MGK
{
	float phi = m_Controls.Q4_realposition*cos_(m_Controls.Q1_realposition - pi / 4);

	J11 = L1*(m_Controls.Q4_realposition*sin_(m_Controls.Q1_realposition - pi / 4)*cos_(m_Controls.Q1_realposition)*sin_(phi) - sin_(m_Controls.Q1_realposition)*cos_(phi));
	J12 = L2*sin_(m_Controls.Q2_realposition);
	J14 = L1*(-cos_(m_Controls.Q1_realposition)*cos_(m_Controls.Q1_realposition - pi / 4)*sin_(phi));

	J21 = -L1*(-m_Controls.Q4_realposition*sin_(m_Controls.Q1_realposition - pi / 4)*cos_(phi));
	J24 = -L1*(cos_(m_Controls.Q1_realposition - pi / 4)*cos_(phi));

	J31 = L1*(m_Controls.Q4_realposition*sin_(m_Controls.Q1_realposition - pi / 4)*sin_(m_Controls.Q1_realposition)*sin_(phi) + cos_(m_Controls.Q1_realposition)*cos_(phi));
	J32 = L2*(-cos_(m_Controls.Q2_realposition));

	J34 = L1*sin_(m_Controls.Q1_realposition)*(-cos_(m_Controls.Q1_realposition - pi / 4))*sin_(phi);
}

///////////////////////////////////////////////////////////////////////////////
// Ryason:  Calculates a spring response based on joint orientation and applies 
VOID CModule1::simple_joint_response()
{
	float k = 200;
	
	//Actuator 1
	if (m_Controls.Q1_realposition <50 * pi / 180)
	{
		m_Outputs.Q1_targettorque = (int)(-1 * k*(50 * pi / 180 - m_Controls.Q1_realposition) / .128);
	}
	else if (m_Controls.Q1_realposition > 110 * pi / 180)
	{
		m_Outputs.Q1_targettorque = (int)(-1 * k*(110 * pi / 180 - m_Controls.Q1_realposition) / .128);
	}
	else
		m_Outputs.Q1_targettorque = 0;

	//Actuator 2 
	if (m_Controls.Q2_realposition < 140 * pi / 180)
	{
		m_Outputs.Q2_targettorque = (int)(k*(140 * pi / 180 - m_Controls.Q2_realposition) / .128);
	}
	else if (m_Controls.Q2_realposition > 190 * pi / 180)
	{
		m_Outputs.Q2_targettorque = (int)(k*(190 * pi / 180 - m_Controls.Q2_realposition) / .128);
	}
	else
		m_Outputs.Q2_targettorque = 0;

	//Actuator 3
	if (m_Controls.Q3_realposition < 80 * pi / 180)
	{
		m_Outputs.Q3_targettorque = (int)(-1 * k*(80 * pi / 180 - m_Controls.Q3_realposition) / .128);
	}
	else if (m_Controls.Q3_realposition > 100 * pi / 180)
	{
		m_Outputs.Q3_targettorque = (int)(-1 * k*(100 * pi / 180 - m_Controls.Q3_realposition) / .128);
	}
	else
		m_Outputs.Q3_targettorque = 0;

	//Actuator 4
	/*if (m_Controls.Q4_realposition > 60)
	{
		m_Outputs.Q4_targettorque = (int)(100.0*(60 - m_Controls.Q4_realposition) / .0513942);
	}
	else if (m_Controls.Q4_realposition > 120)
	{
		m_Outputs.Q4_targettorque = (int)(100.0*(120 - m_Controls.Q4_realposition) / .0513942);
	}
	else
		m_Outputs.Q4_targettorque = 0;*/
}

///////////////////////////////////////////////////////////////////////////////
// Ryason:  Calculates the reference force to be applied 
VOID CModule1::simple_box_interior()
{
	//Initializes the bounds
	float X_L = .23;
	float X_U = .33;
	float Y_L = -.07;
	float Y_U = .10;
	float Z_L = -.03;
	float Z_U = .04;
	float k=300;			//Spring Constant, k

	//Check if the end effector is out of the bounds
	if (m_ADS_data.MotorComm.PX < X_L)
		m_ADS_data.MotorComm.FX = (X_L - m_ADS_data.MotorComm.PX)*k;
	else if (m_ADS_data.MotorComm.PX > X_U)
		m_ADS_data.MotorComm.FX = (X_U - m_ADS_data.MotorComm.PX)*k;
	else m_ADS_data.MotorComm.FX = 0;

	if (m_ADS_data.MotorComm.PY < Y_L)
		m_ADS_data.MotorComm.FY = (Y_L - m_ADS_data.MotorComm.PY)*k;
	else if (m_ADS_data.MotorComm.PY > Y_U)
		m_ADS_data.MotorComm.FY = (Y_U - m_ADS_data.MotorComm.PY)*k;
	else m_ADS_data.MotorComm.FY = 0;

	if (m_ADS_data.MotorComm.PZ < Z_L)
		m_ADS_data.MotorComm.FZ = (Z_L - m_ADS_data.MotorComm.PZ)*k;
	else if (m_ADS_data.MotorComm.PZ > Z_U)
		m_ADS_data.MotorComm.FZ = (Z_U - m_ADS_data.MotorComm.PZ)*k;
	else m_ADS_data.MotorComm.FZ = 0;
}

///////////////////////////////////////////////////////////////////////////////
// Ryason:  Sets a reference torque based on the static force feedback at the end effector
//DATE: 7 / 28 / 2017, updated 5 / 8 / 2018 with MGK
VOID CModule1::set_reference_torque()
{
	m_Outputs.Q1_targettorque =		(int)(-1 * t1 * (421875 / 6859) / .126495);
	m_Outputs.Q2_targettorque =	(int)(-1 * t2 * (421875 / 6859) / .126495);
	m_Outputs.Q3_targettorque =	(int)(-1 * t3 * (4554 / 130) / .126495);
	m_Outputs.Q4_targettorque =	-1*(int)(t4 * 50 / .0513942);
}

VOID CModule1::set_dynamic_torque()
{
	phi = -1 * ((m_Controls.Q4_realposition)* cos_(m_Controls.Q1_realposition + pi / 4) + pi / 2);

	t1 = (int)((L1*(m_ADS_data.MotorComm.FX*sin_(phi)*cos_(m_Controls.Q1_realposition) + m_ADS_data.MotorComm.FY*sin_(phi)*sin_(m_Controls.Q1_realposition) + m_ADS_data.MotorComm.FX*m_Controls.Q4_realposition*sin_(m_Controls.Q1_realposition)*cos_(phi)*sin_(2.356 + m_Controls.Q1_realposition) - m_ADS_data.MotorComm.FZ*m_Controls.Q4_realposition*sin_(phi)*sin_(2.356 + m_Controls.Q1_realposition) - m_ADS_data.MotorComm.FY*m_Controls.Q4_realposition*cos_(m_Controls.Q1_realposition)*sin_(2.356 + m_Controls.Q1_realposition)))*(421875 / 6859) / .128);
	t2 = (int)((-L2*m_ADS_data.MotorComm.FX*sin_(m_Controls.Q2_realposition) + L2*m_ADS_data.MotorComm.FY*cos_(m_Controls.Q2_realposition))*(421875 / 6859) / .128);
	t4 = (int)((-L1*sin_(0.785 + m_Controls.Q1_realposition)*(m_ADS_data.MotorComm.FX*sin_(m_Controls.Q1_realposition)*cos_(phi) - m_ADS_data.MotorComm.FZ*sin_(phi) - m_ADS_data.MotorComm.FY*cos_(phi)*cos_(m_Controls.Q1_realposition))) * 50 / .0513942);
	
	t3 = 0;
	//t3 = (int)(-TZ*(1 + L5*cos(m_Controls.Q3_realposition) / (L4*sqrt_(1 - L5 ^ 2 * sin(m_Controls.Q3_realposition) ^ 2 / L4 ^ 2))));

	m_Outputs.Q1_targettorque = -1 * t1;
	m_Outputs.Q2_targettorque = -1 * t2;
	m_Outputs.Q3_targettorque = -1 * t3;
	m_Outputs.Q4_targettorque = t4;
	
}

VOID CModule1::force_response()
{
	phi = -1 * ((m_Controls.Q4_realposition)* cos_(m_Controls.Q1_realposition + pi / 4) + pi / 2);

	t1 = t1 + (L1*(m_ADS_data.MotorComm.FX*sin_(phi)*cos_(m_Controls.Q1_realposition) 
		+ m_ADS_data.MotorComm.FY*sin_(phi)*sin_(m_Controls.Q1_realposition) 
		+ m_ADS_data.MotorComm.FX*m_Controls.Q4_realposition*sin_(m_Controls.Q1_realposition)*cos_(phi)*sin_(2.356 + m_Controls.Q1_realposition) 
		//- m_ADS_data.MotorComm.FZ*m_Controls.Q4_realposition*sin_(phi)*sin_(2.356 + m_Controls.Q1_realposition) 
		- m_ADS_data.MotorComm.FY*m_Controls.Q4_realposition*cos_(m_Controls.Q1_realposition)*sin_(2.356 + m_Controls.Q1_realposition)));
	
	t2 = t2 + (-L2*m_ADS_data.MotorComm.FX*sin_(m_Controls.Q2_realposition) 
		+ L2*m_ADS_data.MotorComm.FY*cos_(m_Controls.Q2_realposition));
	
	//t4 = -(L1*sin_(0.785 + m_Controls.Q1_realposition)*(m_ADS_data.MotorComm.FX*sin_(m_Controls.Q1_realposition)*cos_(phi) 
	t4 = t4 - (L1*cos_(0.785 + m_Controls.Q1_realposition)*(m_ADS_data.MotorComm.FX*sin_(m_Controls.Q1_realposition)*cos_(phi)
		- m_ADS_data.MotorComm.FZ*sin_(phi) 
		- m_ADS_data.MotorComm.FY*cos_(phi)*cos_(m_Controls.Q1_realposition))) ;


	//t3 = (int)(-TZ*(1 + L5*cos(m_Controls.Q3_realposition) / (L4*sqrt_(1 - L5 ^ 2 * sin(m_Controls.Q3_realposition) ^ 2 / L4 ^ 2))));
    t3 = m_ADS_data.MotorComm.TY;
}

VOID CModule1::compensate_gravity()
{
	//Temporary weighting coef. until proper mass properties obtained
    float w1 = 0.25; //.225
    float w2 = 0;
	float w3 = 0.35;
	float w4 = 0.50;

	t1 = t1 + g*((sin_(phi)*sin_(m_Controls.Q1_realposition) - m_Controls.Q4_realposition*cos_(phi)*cos_(m_Controls.Q1_realposition)*sin_(5 / 4 * pi + m_Controls.Q1_realposition))*(mG*L1 + mJ*Jcmz + mM*L1 + mP*L1 + mQ*L1 + mF*Fcmz + mF*Lcmz + mH*Hcmz + mI*L1)
		+ cos_(m_Controls.Q1_realposition)*(mF*Fcmx + mF*Lcmx + mH*Hcmx + mI*Icmx)
		+ mI*Icmy*sin_(m_Controls.Q1_realposition))*w1;

	t2 = t2 + g*(cos_(m_Controls.Q2_realposition)*(mC*Ccmx + mD*L3 + mF*L3 + mF*L3 + mM*L3 + mG*(Gcmx + L3) - mQ*L2)
		+ mE*(Ecmx*cos_(m_Controls.Q2_realposition) - Ecmy*sin_(m_Controls.Q2_realposition)) + mP*(cos_(m_Controls.Q2_realposition)*(L3 + Pcmx) - Pcmy*sin_(m_Controls.Q2_realposition)))*w2;

	t4 = t4 + sin_(3 * pi / 4 + m_Controls.Q1_realposition)*g*cos_(phi)*cos_(m_Controls.Q1_realposition)*(mF*Fcmz + mF*Lcmz + mG*L1 + mH*Hcmz + mI*L1 + mJ*Jcmz + mM*L1 + mP*L1 + mQ*L1)*w4;

	t3 = t3 + (mA*Acmx*g*cos_(m_Controls.Q3_realposition)	
		+ mC*g*cos_(qB)*(L4 + L5*cos_(m_Controls.Q3_realposition) / sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))
		+ mB*Bcmx*g*cos_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))))
		+ mQ*g*(Qcmx*cos_(qQ) - Qcmy*sin_(qQ))*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))))
		+ mD*g*(cos_(qB)*(L4 + L5*cos_(m_Controls.Q3_realposition) / sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))) + Dcmx*cos_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))) - Dcmy*sin_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))))
		+ 0.0325*mP*g*(30.76923076923077*cos_(qB)*(L4 + L5*cos_(m_Controls.Q3_realposition) / sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))
		+ cos_(qM)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))))
		+ 2.055495384615385*cos_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))))
		- 1.955215384615385*sin_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))))
		- 30.76923076923077*L4*sin_(qM)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))))
		+ 0.0635445*mM*g*(15.73700320248015*cos_(qB)*(L4 + L5*cos_(m_Controls.Q3_realposition) / sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))
		+ 1.051288467137203*cos_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))))
		+ 15.73700320248015*Mcmx*cos_(qM)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))))
		- sin_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))))
		- 15.73700320248015*Mcmy*sin_(qM)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))))
		- 0.0635445*mF*g*(sin_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))) - 15.73700320248015*cos_(qB)*(L4 + L5*cos_(m_Controls.Q3_realposition) / sqrt_(1 -
		pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2))) - 1.051288467137203*cos_(qB)*(1 + L5*cos_(m_Controls.Q3_realposition) / (L4*sqrt_(1 - pow_(L5, 2)*pow_(sin_(m_Controls.Q3_realposition), 2) / pow_(L4, 2)))))
		- 0.0325*sin_(2.356194490192345 + m_Controls.Q1_realposition)) * w3 ;
}

VOID CModule1::compensate_staticmu()
//NOT UPDATED FOR MGK
{
    t1 = 0;
    t2 = 0;
    t3 = 0;
    t4 = 0;
	/*if (m_Controls.Q1_realvelocity > 0)
	{
		//t1 = 18/421875 * 6859 * .126495;
		//t1 = -.03702;
        //t1 = 0;
	}
	else if (m_Controls.Q1_realvelocity < 0)
	{
		//t1 = -19 / 421875 * 6859 * .126495;
		t1 = .03902;
        //t1 = 0;
	}
	else
		t1 = 0;

	if (m_Controls.Q2_realvelocity > 0)
	{
		//t2 = 16 / 421875 * 6859 * .126495;
		t2 = -.032906;
	}
	else if (m_Controls.Q2_realvelocity < 0)
	{
		//t2 = -16 / 421875 * 6859 * .126495;
		t2 = .032906;
	}
	else
		t2 = 0;

	if (m_Controls.Q3_realvelocity > 0)
	{
		//t3 = 17/4554 * 130 * .126495;
		t3 = 0.061386;
	}
	else if (m_Controls.Q3_realvelocity < 0)
	{
		//t3 = -16 / 4554 * 130 * .126495;
		t3 = -0.05778;
	}
	else
		t3 = 0;

	if (m_Controls.Q4_realvelocity > 0)
	{
		//t4 = 100 / 50 * .0513942;
		//t4 = 0.1027884;
		t4 = 0;
	}
	else if (m_Controls.Q4_realvelocity < 0)
	{
		//t4 = -125 / 50 * .0513942;
		//t4 = -0.1284855;
		t4 = 0;
	}
	else
		t4 = 0;
        */
}

VOID CModule1::zero_torque()
{
	m_ADS_data.MotorComm.FX = 0;
	m_ADS_data.MotorComm.FY = 0;
	m_ADS_data.MotorComm.FZ = 0;

	m_Outputs.Q1_targettorque = 0;
	m_Outputs.Q2_targettorque = 0;
	m_Outputs.Q3_targettorque = 0;
	m_Outputs.Q4_targettorque = 0;
}

VOID CModule1::sim_laryngoscopelift()
{
    float lev = 0.1;         //Lever Arm for CoF

    m_ADS_data.MotorComm.FX = (P0x - m_ADS_data.MotorComm.PX)*kf;
    m_ADS_data.MotorComm.FY = (P0y - m_ADS_data.MotorComm.PY)*kf;
    m_ADS_data.MotorComm.FZ = (P0z - m_ADS_data.MotorComm.PZ)*kf;

    m_ADS_data.MotorComm.TY = sqrt_(m_ADS_data.MotorComm.FX*m_ADS_data.MotorComm.FX + m_ADS_data.MotorComm.FY*m_ADS_data.MotorComm.FY)*lev;
}
